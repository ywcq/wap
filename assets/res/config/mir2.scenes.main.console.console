local current = ...local common = import("..common.common")local replaceAsk = import(".replaceAsk")local widgetDef = import(".widget._def")local widgetDelegate = import(".widget._delegate")local console = class("console", function ()	return display.newNode()end)table.merge(console, {	widgets,	editting,	controller,	skills,	btnCallbacks,	editBg,	btnBg,	btnAreaMaxLine = 6,	saveList = "_list",	btnAreaBegin = 23,	btnAreaSpace = 75,	saveCurrent = "_current",	btnAreaLineNum = display.width - 960 > 80 and 4 or 3,	z = {		btnAreaBg = 2,		editBg = 1,		widget = 10	}})skillBtnPosID = 0local function getPos (px, py, r, a, w, elementNumber)	--圆心坐标	local x0 = px	local y0 = py	--半径	local r = r or 50	--圆上点初始坐标	local x1 = 0	local y1 = 0	local listPos = {}	local degree = (w - a) / elementNumber	--72度一个间隔输出圆上坐标	local count = 0	for i = a, w, degree do		count = count + 1		if count > elementNumber then			break		end		x1 = x0 + r * math.cos(-i * math.pi / 180)		y1 = y0 + r * math.sin(-i * math.pi / 180)		table.insert(listPos, {x = x1, y = y1})	end	--table.remove(listPos)	return listPos	endlocal function getPos2 (px, py, r, a, w, elementNumber)	--圆心坐标	local x0 = px	local y0 = py	--半径	local r = r or 50	--圆上点初始坐标	local x1 = 0	local y1 = 0	local listPos = {}	local degree = (w - a) / elementNumber	--72度一个间隔输出圆上坐标	local count = 0	for i = a, w, degree do		count = count + 1		if count > elementNumber then			break		end		x1 = x0 + r * math.cos(-i * math.pi / 180)		y1 = y0 + r * math.sin(-i * math.pi / 180)		table.insert(listPos, {x = x1, y = y1})	end	--table.remove(listPos)	return listPos	end	local skillBtnPos1Put = getPos(display.width - 50, 60, 145, 180, 300, 4)local skillBtnPos2Put = getPos2(display.width - 55, 60, 222, 180, 290, 5)console.ctor = function (self)	g_data.mark.playerName = common.getPlayerName()	local cacheData = cache.getDiy(common.getPlayerName(), self.saveCurrent)	--local datas = cache.getDiy(common.getPlayerName(), self.saveCurrent)	local KcUi = cache.getKcDiy()	local datas = cacheData or KcUi or clone(widgetDef.default)	g_data.setting.chat.whisperLimit=40	if WIN32_OPERATE then		for _, info in ipairs(widgetDef.default_pc) do			local exist = false			for _, v in ipairs(datas) do				if info.key == v.key then					exist = true				end			end			if not exist then				table.insert(datas, info)			end		end		g_data.bag.customs = cache.getCustoms(common.getPlayerName())	end	self.widgets = {}	local putid = 0	for i, v in ipairs(datas) do		local config = widgetDef.getConfig(v)		if config and config.btntype == "skill" then			--初始化技能数量			skillBtnPosID = skillBtnPosID + 1			putid = putid + 1			local skillPos1Put = skillBtnPos1Put[putid]			if skillPos1Put and putid <= 4 then				if not cacheData then					v.x = skillPos1Put.x					v.y = skillPos1Put.y				end			elseif putid >= 5 and putid < 10 then				local skillPos2Put = skillBtnPos1Put[putid - 4]				if not cacheData then					v.x = skillPos2Put.x					v.y = skillPos2Put.y				end			end		end		if config.btntype ~= "custom" or WIN32_OPERATE then			self.addWidget(self, v)		end	end	self.size(self, display.width, display.height)	self.controller = import(".controller", current).new(self)	self.skills = import(".skills", current).new(self)	self.btnCallbacks = import(".btnCallbacks", current).new(self)	self.autoRat = import(".autoRat", current).new(self)	self.autoPickUp = import(".autoPickUp", current).new(self)	return endconsole.resetAutoRat = function (self)	self.autoRat = import(".autoRat", current).new(self)	return endconsole.get = function (self, key)	return self.widgets[key]endconsole.setWidgetSelect = function (self, key, select)	local wid = self.get(self, key)	if wid and wid.btn.setIsSelect then		wid.btn:setIsSelect(select)	end	return endconsole.call = function (self, key, method, ...)	local inst = self.get(self, key)	if inst and inst[method] then		inst[method](inst, ...)	end	return endfunction console:addWidget(data, ani)	local config = widgetDef.getConfig(data)	--dump(data)	if config then		if config.fixedX then			data.x = config.fixedX		end		if config.fixedY then			data.y = config.fixedY		end		if data.btnpos then			print("btnpos",data.btnpos)			local pos = string.split(data.btnpos, "-")			local x1=(tonumber(pos[1]))%2+1			local y1=(tonumber(pos[2]))%4+1			local posData = getPos2(display.width - 50, 60, 145, 180, 300, 4)			if x1~=1 then posData = getPos(display.width - 55, 60, 222, 180, 290, 5) end			print(x1,y1)			data.x = posData[y1].x			data.y = posData[y1].y		end		local node = import(".widget." .. config.class, current).new(config, data):add2(self, config.z or self.z.widget)		node.data = data		node.config = config		btn = node.btn or node		if config.key == "btnSkillTemp" then			btn:setName("diy_" .. data.key)		else			btn:setName("diy_" .. config.name)		end		self.widgets[data.key] = widgetDelegate.extend(node, self)		self:resetBtnAreaBtnPos(node, ani)		if self.editting then					node:_startEdit()		end	end	if main_scene.ui and main_scene.ui.panels.diy then		main_scene.ui.panels.diy:checkSelect(data.key, self)	endendfunction console:addWidgetByPanel(data, form)	--如果存在一个相同的技能直接return	if self:get(data.key) then		return "exist"	end	local config = widgetDef.getConfig(data)	if not config then		return	end	--dump(data)	if config.class == "btnMove" then		--替换相等坐标									for k, v in pairs(self.widgets) do			if v.__cname == "btnMove" and v.data.x and math.floor(v.data.x) == math.floor(data.x) and math.floor(v.data.y) == math.floor(data.y) then				self:removeWidget(v.data.key)				self:addWidget(data)				return			end		end		--不相等直接添加		self:addWidget(data)		return	end	--其它图标	self:addWidget(data)endconsole.removeWidget = function (self, key)	if self.widgets[key] then		self.widgets[key]:removeSelf()		self.widgets[key] = nil	end	if main_scene.ui and main_scene.ui.panels.diy then		main_scene.ui.panels.diy:checkSelect(key, self)	end	return endfunction console:btnpos2pos(pos)	pos = string.split(pos, "-")	local x = display.width - (pos[2] - 0.5) * self.btnAreaSpace - self.btnAreaBegin	local y = (pos[1] - 0.5) * self.btnAreaSpace + self.btnAreaBegin	return x, yendfunction console:pos2btnpos(x, y)	local rect = self:getBtnAreaRect()		if not cc.rectContainsPoint(rect, cc.p(x, y)) then		return	end	x = x - rect.x	x = self.btnAreaLineNum - math.modf(x / self.btnAreaSpace)	x = math.max(1, math.min(x, self.btnAreaLineNum))	y = y - self.btnAreaBegin	y = math.modf(y / self.btnAreaSpace) + 1	y = math.max(1, math.min(y, self.btnAreaMaxLine))	return y .. "-" .. xendconsole.findWidgetWithBtnpos = function (self, pos)	for k, v in pairs(self.widgets) do		if v.__cname == "btnMove" and v.data.btnpos and v.data.btnpos == pos then			return v		end	end	return endfunction console:resetBtnAreaBtnPos(v, ani)	do return end	if v.__cname == "btnMove" and v.data.btnpos then		local x, y = self:btnpos2pos(v.data.btnpos)		if x ~= v:getPositionX() or y ~= v:getPositionY() then						if ani then				v:moveTo(0.1, x, y)			else				v:pos(x, y)			end		end	endendconsole.resetAllBtnAreaBtnPos = function (self, ani)	for k, v in pairs(self.widgets) do		self.resetBtnAreaBtnPos(self, v, ani)	end	return endconsole.startEdit = function (self)	self.call(self, "btnMode", "showModeSelect")	for k, v in pairs(self.widgets) do		v._startEdit(v)		v.show(v)	end	self.editting = true	return endconsole.endEdit = function (self)	for k, v in pairs(self.widgets) do		v._endEdit(v)	end	self.editting = false	self.saveEdit(self)	return endconsole.saveEdit = function (self, filename)	local datas = {}	local nodes = sortNodes(table.values(self.widgets))	for i, v in ipairs(nodes) do		if v.data.btnpos then			v.data.btnpos=nil		end		table.insert(datas, 1, v.data)	end	cache.saveDiy(common.getPlayerName(), filename or self.saveCurrent, datas)	return endconsole.saveKcUi = function (self)	local datas = {}	local nodes = sortNodes(table.values(self.widgets))	for i, v in ipairs(nodes) do		table.insert(datas, 1, v.data)	end	cache.saveKcDiy(datas)	return endconsole.showRect = function (self, widget, key)	self.hideAllRect(self)	widget = widget or self.get(self, key)	if not widget then		return 	end	widget._showRect(widget)	return endconsole.hideAllRect = function (self)	for k, v in pairs(self.widgets) do		v._hideRect(v)	end	return endconsole.showEditBg = function (self, b)	if not self.editBg then		self.editBg = cc.LayerColor:create(cc.c4b(0, 0, 0, 128)):size(display.width, display.height):add2(self, self.z.editBg)		display.newNode():size(self.editBg:getContentSize()):add2(self.editBg):enableClick(function ()			self:hideAllRect()			return 		end)	end	self.editBg:setVisible(b)	return endconsole.getBtnAreaRect = function (self)	return cc.rect(display.width - self.btnAreaSpace*self.btnAreaLineNum - self.btnAreaBegin, 0, self.btnAreaSpace*self.btnAreaLineNum + self.btnAreaBegin, self.btnAreaSpace*self.btnAreaMaxLine + self.btnAreaBegin)endfunction console:checkBtnAreaShow(p, isHide)	local rect = self:getBtnAreaRect()	if p then		isHide = isHide or not cc.rectContainsPoint(rect, p)	end	if not self.btnBg then		self.btnBg = display.newScale9Sprite(res.getframe2("pic/scale/scale6.png"), rect.x, rect.y, cc.size(rect.width, rect.height)):anchor(0, 0):add2(self, self.z.btnAreaBg)	end	--取消背景	self.btnBg:setVisible(false)	--self.btnBg:setVisible(not isHide)endconsole.fillPropTest = function (self)	for k, v in pairs(self.widgets) do		if v.config.btntype == "prop" then			v.prop_fill_test(v)		end		if v.config.btntype == "custom" then			v.custom_fill_test(v)		end	end	return endconsole.update = function (self, dt)	for k, v in pairs(self.widgets) do		if v.update then			v.update(v, dt)		end	end	self.controller:update(dt)	return endconsole.hidePet = function (self)		return endreturn console